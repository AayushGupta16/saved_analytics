Python Code Catalog
Generated on: 2024-12-09 05:45:41
================================================================================

File: ./count.py
Lines of code: 81
--------------------------------------------------------------------------------

import os
import datetime

def get_python_files(directory="."):
    """
    Gets a list of all Python files in the directory and its subdirectories,
    excluding virtual environment directories.
    Returns a list of file paths.
    """
    python_files = []
    
    # Common virtual environment directory names to exclude
    venv_dirs = {'venv', 'env', '.env', '.venv', 'virtualenv', '.pytest_cache', '__pycache__'}
    
    for root, dirs, files in os.walk(directory):
        # Remove venv directories from dirs list to prevent walking into them
        dirs[:] = [d for d in dirs if d not in venv_dirs]
        
        for file in files:
            if file.endswith('.py'):
                python_files.append(os.path.join(root, file))
    
    return sorted(python_files)  # Sort for consistent output

def create_python_catalog(output_file="python_code_catalog.txt"):
    """
    Creates a text file containing all Python code from the project with file indicators.
    """
    python_files = get_python_files()
    
    if not python_files:
        print("No Python files found in the current directory and its subdirectories.")
        return
    
    try:
        with open(output_file, 'w', encoding='utf-8') as catalog:
            # Write header
            catalog.write("Python Code Catalog\n")
            catalog.write(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            catalog.write("=" * 80 + "\n\n")
            
            total_files = 0
            total_lines = 0
            
            for file_path in python_files:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        lines = content.count('\n') + 1
                        
                        # Write file header
                        catalog.write(f"File: {file_path}\n")
                        catalog.write(f"Lines of code: {lines}\n")
                        catalog.write("-" * 80 + "\n\n")
                        
                        # Write file content
                        catalog.write(content)
                        
                        # Add spacing between files
                        catalog.write("\n\n" + "=" * 80 + "\n\n")
                        
                        total_files += 1
                        total_lines += lines
                        
                except Exception as e:
                    print(f"Error reading {file_path}: {str(e)}")
            
            # Write summary at the end
            catalog.write(f"\nSummary:\n")
            catalog.write(f"Total Python files processed: {total_files}\n")
            catalog.write(f"Total lines of Python code: {total_lines}\n")
            
        print(f"Python code catalog has been created: {output_file}")
        print(f"Total Python files processed: {total_files}")
        print(f"Total lines of Python code: {total_lines}")
        
    except Exception as e:
        print(f"Error creating catalog file: {str(e)}")

if __name__ == "__main__":
    create_python_catalog()

================================================================================

File: ./metrics/avg_streams_per_user.py
Lines of code: 11
--------------------------------------------------------------------------------

from .weekly_intervals import display_weekly_metrics

def display_avg_streams_per_user(streams_df):
    display_weekly_metrics(
        streams_df,
        "Average Streams per User",
        'created_at',
        'user_id',
        'mean',
        color='orange'
    )

================================================================================

File: ./metrics/monthly_active_users.py
Lines of code: 11
--------------------------------------------------------------------------------

from .monthly_utils import display_monthly_metrics

def display_monthly_active_users(streams_df):
    display_monthly_metrics(
        streams_df,
        "Active Users",
        'created_at',
        'user_id',
        'unique_count',
        color='#FF69B4'
    )

================================================================================

File: ./metrics/monthly_retention.py
Lines of code: 10
--------------------------------------------------------------------------------

from .monthly_utils import display_monthly_metrics

def display_monthly_retention(streams_df):
    display_monthly_metrics(
        streams_df,
        "User Retention",
        'created_at',
        agg_function='retention',
        color='#FFD700'
    )

================================================================================

File: ./metrics/monthly_total_streams.py
Lines of code: 9
--------------------------------------------------------------------------------

from .monthly_utils import display_monthly_metrics

def display_monthly_total_streams(streams_df):
    display_monthly_metrics(
        streams_df,
        "Total Streams",
        'created_at',
        color='#9c27b0'
    )

================================================================================

File: ./metrics/monthly_utils.py
Lines of code: 242
--------------------------------------------------------------------------------

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go  # Add this line
from datetime import datetime, timezone
import numpy as np


def get_extrapolated_monthly_data(df: pd.DataFrame, 
                                  date_column: str, 
                                  count_column: str = None, 
                                  agg_function: str = 'count') -> pd.DataFrame:
    """
    Calculate monthly data with clear extrapolation for the current month.
    
    Parameters:
        df: DataFrame with the data
        date_column: Name of the date column
        count_column: Column to count unique values from (optional)
        agg_function: 'count', 'mean', 'unique_count', or 'retention'
    """
    if df.empty:
        return pd.DataFrame()
    
    # Ensure datetime is UTC
    df = df.copy()
    df[date_column] = pd.to_datetime(df[date_column], utc=True)
    
    # Get current month information
    today = pd.Timestamp.now(tz='UTC')
    current_month_start = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    days_in_month = today.days_in_month  # Updated line
    days_elapsed = (today - current_month_start).days + 1
    
    # Separate current month and historical data
    current_month = df[df[date_column] >= current_month_start]
    historical_data = df[df[date_column] < current_month_start]
    
    # Aggregate historical data based on function type
    if agg_function == 'retention':
        monthly_data = calculate_retention(historical_data, date_column)
    else:
        if agg_function == 'unique_count':
            monthly_data = historical_data.groupby(pd.Grouper(key=date_column, freq='M'))[count_column].nunique()
        elif agg_function == 'mean':
            grouped = historical_data.groupby([pd.Grouper(key=date_column, freq='M'), count_column]).size()
            monthly_data = grouped.groupby(level=0).mean()
        else:  # count
            monthly_data = historical_data.groupby(pd.Grouper(key=date_column, freq='M')).size()
        
        monthly_data = monthly_data.reset_index()
        monthly_data.columns = ['date', 'value']
    
    monthly_data['is_extrapolated'] = False
    
    # Calculate and append extrapolated data if we have current month data
    if not current_month.empty:
        if agg_function == 'retention':
            # Special handling for retention metrics
            current_value = calculate_current_month_retention(current_month, historical_data, date_column)
        else:
            if agg_function == 'unique_count':
                current_value = current_month[count_column].nunique()
            elif agg_function == 'mean':
                current_value = current_month.groupby(count_column).size().mean()
            else:
                current_value = len(current_month)
            
            # Extrapolate to full month
            current_value = np.ceil((current_value / days_elapsed) * days_in_month)
        
        extrapolated_row = pd.DataFrame({
            'date': [current_month_start],
            'value': [current_value],
            'is_extrapolated': [True]
        })
        
        monthly_data = pd.concat([monthly_data, extrapolated_row], ignore_index=True)
    
    return monthly_data.sort_values('date', ascending=True)

def create_monthly_plot(data: pd.DataFrame, 
                        title: str,
                        y_axis_title: str,
                        color: str = '#1f77b4',
                        show_growth: bool = True) -> go.Figure:  # Updated type annotation
    """
    Create a consistent monthly plot with improved styling
    """
    # Calculate month-over-month growth
    if show_growth and len(data) > 1:
        data = data.copy()
        data['growth'] = data['value'].pct_change() * 100
    
    fig = px.line(
        data,
        x='date',
        y='value',
        title=title,
        markers=True,
        color_discrete_sequence=[color]
    )
    
    # Update layout
    fig.update_layout(
        hovermode='x unified',
        hoverlabel=dict(
            bgcolor="white",
            font_size=14,
            font_color="black",
            bordercolor="black"
        ),
        title=dict(
            text=title,
            x=0.5,
            y=0.95,
            xanchor='center',
            yanchor='top',
            font_size=24
        ),
        xaxis_title="Month",
        yaxis_title=y_axis_title,
        height=600,
        xaxis=dict(tickangle=-45)
    )
    
    # Style the lines differently for actual vs extrapolated data
    for i, row in data.iterrows():
        if row['is_extrapolated']:
            fig.add_scatter(
                x=[row['date']],
                y=[row['value']],
                mode='markers+lines',
                line=dict(dash='dot', color=color),
                marker=dict(size=10, color=color, symbol='star'),
                name='Projected',
                showlegend=i == len(data) - 1,
                hovertemplate="<br>".join([
                    "<b>Month:</b> %{x|%B %Y}",
                    f"<b>{y_axis_title}:</b> %{{y:.1f}} (Projected)",
                    "<extra></extra>"
                ])
            )
    
    # Update main trace
    fig.update_traces(
        line=dict(width=2),
        marker=dict(size=8),
        hovertemplate="<br>".join([
            "<b>Month:</b> %{x|%B %Y}",
            f"<b>{y_axis_title}:</b> %{{y:.1f}}",
            f"<b>MoM Growth:</b> {'+' if show_growth else ''}" + "%{customdata[0]:.1f}%" if show_growth else "",
            "<extra></extra>"
        ]),
        customdata=data[['growth']] if show_growth else None,
        selector=dict(mode='lines+markers')
    )
    
    return fig

def display_monthly_metrics(data_df: pd.DataFrame, 
                          metric_name: str,
                          date_column: str = 'created_at',
                          count_column: str = None,
                          agg_function: str = 'count',
                          color: str = '#1f77b4') -> None:
    """
    Display monthly metrics with improved visualization
    """
    st.header(f'{metric_name} (Monthly)')
    
    if data_df.empty:
        st.write(f"No data available for {metric_name}")
        return
    
    # Get monthly data with extrapolation
    monthly_data = get_extrapolated_monthly_data(
        data_df, 
        date_column, 
        count_column, 
        agg_function
    )
    
    # Create and display plot
    fig = create_monthly_plot(
        monthly_data,
        title=f'{metric_name} (Monthly)',
        y_axis_title=metric_name,
        color=color
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Display data table with clear extrapolation marking
    display_df = monthly_data.copy()
    display_df['Status'] = display_df['is_extrapolated'].map({True: '📊 Projected', False: '✓ Actual'})
    display_df = display_df.drop('is_extrapolated', axis=1)
    display_df.columns = ['Month', 'Value', 'Status']
    display_df['Month'] = display_df['Month'].dt.strftime('%B %Y')
    
    st.subheader(f"Monthly {metric_name} Data")
    st.dataframe(
        display_df.sort_values('Month', ascending=False),
        hide_index=True
    )

# Helper function for retention calculations
def calculate_retention(df: pd.DataFrame, date_column: str) -> pd.DataFrame:
    """Calculate historical retention rates"""
    monthly_users = df.groupby([pd.Grouper(key=date_column, freq='M'), 'user_id']).size().reset_index()
    months = sorted(monthly_users[date_column].unique())
    
    retention_data = []
    for i in range(1, len(months)):
        current_month = months[i]
        previous_month = months[i-1]
        
        previous_users = set(monthly_users[monthly_users[date_column] == previous_month]['user_id'])
        current_users = set(monthly_users[monthly_users[date_column] == current_month]['user_id'])
        
        retained_users = len(previous_users.intersection(current_users))
        retention_rate = (retained_users / len(previous_users) * 100) if previous_users else 0
        
        retention_data.append({
            'date': current_month,
            'value': retention_rate
        })
    
    return pd.DataFrame(retention_data)

def calculate_current_month_retention(current_data: pd.DataFrame, 
                                   historical_data: pd.DataFrame, 
                                   date_column: str) -> float:
    """Calculate retention rate for the current month"""
    last_month = pd.Timestamp.now(tz='UTC').replace(day=1) - pd.Timedelta(days=1)
    last_month_users = set(historical_data[
        historical_data[date_column].dt.month == last_month.month
    ]['user_id'])
    current_users = set(current_data['user_id'])
    
    retained_users = len(last_month_users.intersection(current_users))
    return (retained_users / len(last_month_users) * 100) if last_month_users else 0

================================================================================

File: ./metrics/new_user_signups.py
Lines of code: 134
--------------------------------------------------------------------------------

import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta, timezone
import numpy as np

def get_fixed_weekly_intervals(df, date_column):
    """
    Assigns each data point to a fixed weekly interval starting from Sept 29, 2024.
    All datetime objects are timezone-aware (UTC).
    """
    if df.empty:
        return pd.DataFrame()
    
    df = df.copy()
    # Ensure datetime is parsed with UTC timezone
    df[date_column] = pd.to_datetime(df[date_column], utc=True)
    
    # Define the start date: Sunday, September 29, 2024, UTC
    start_date = pd.Timestamp('2024-09-29', tz='UTC')
    
    # Calculate the week number for each date
    df['week_number'] = ((df[date_column] - start_date) // pd.Timedelta(weeks=1)) + 1
    df['week_start'] = start_date + (df['week_number'] - 1) * pd.Timedelta(weeks=1)
    
    return df

def get_weekly_signups(users_df, date_column='created_at'):
    if users_df.empty:
        return pd.DataFrame()
    
    df = get_fixed_weekly_intervals(users_df, date_column)
    
    # Aggregate new signups per week
    weekly_signups = df.groupby('week_start').size().reset_index(name='new_users')
    
    # Identify the current week
    today = pd.Timestamp(datetime.now(timezone.utc).date(), tz='UTC')
    current_week_start = start_of_week(today)
    
    # Separate completed weeks and the current week
    completed_weeks = weekly_signups[weekly_signups['week_start'] < current_week_start]
    current_week_data = df[df['week_start'] == current_week_start]
    
    # Estimate current week's new signups
    if not current_week_data.empty:
        days_elapsed = (today - current_week_start).days + 1  # Including today
        if days_elapsed == 0:
            days_elapsed = 1  # Prevent division by zero
        
        avg_per_day = current_week_data.groupby('user_id').size().count() / days_elapsed
        estimated_new_users = int(np.floor(avg_per_day * 7))
        
        # Append estimated data using pd.concat
        estimated_row = pd.DataFrame({
            'week_start': [current_week_start],
            'new_users': [estimated_new_users]
        })
        completed_weeks = pd.concat([completed_weeks, estimated_row], ignore_index=True)
    
    return completed_weeks.sort_values('week_start', ascending=False)

def start_of_week(date):
    """
    Returns the start of the week (Sunday) for a given date.
    """
    return date - pd.Timedelta(days=date.weekday() + 1 if date.weekday() != 6 else 0)

def display_new_user_signups(users_df):
    st.header('New User Signups (Weekly Intervals)')
    if not users_df.empty:
        weekly_signups = get_weekly_signups(users_df, 'created_at')
        
        if weekly_signups.empty:
            st.write("No weekly signup data available.")
            return
        
        # Identify the current week for styling
        today = pd.Timestamp(datetime.now(timezone.utc).date(), tz='UTC')
        current_week_start = start_of_week(today)
        
        fig = px.line(
            weekly_signups,
            x='week_start',
            y='new_users',
            title='New User Signups (Weekly Intervals)',
            markers=True,
            color_discrete_sequence=['green']
        )
        
        fig.update_layout(
            hovermode='x unified',
            hoverlabel=dict(
                bgcolor="white",
                font=dict(
                    color="black",
                    size=14
                ),
                bordercolor="black"
            ),
            title=dict(
                text='New User Signups (Weekly Intervals)',
                x=0.5,
                y=0.95,
                xanchor='center',
                yanchor='top',
                font=dict(
                    size=24
                )
            ),
            xaxis_title="Week Starting",
            yaxis_title="Number of New Users",
            height=600,
            xaxis=dict(tickangle=-45)
        )
        
        # Style the estimated current week
        fig.update_traces(
            line=dict(width=2, dash='dash' if weekly_signups['week_start'].iloc[-1] == current_week_start else 'solid'),
            marker=dict(size=10, color='green'),
            hovertemplate="<br>".join([
                "<b>Week Starting:</b> %{x|%Y-%m-%d}",
                "<b>New Users:</b> %{y}",
                "<extra></extra>"
            ])
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        st.subheader("Weekly New User Signups Data")
        st.dataframe(weekly_signups.sort_values('week_start', ascending=False))
    else:
        st.write("No data available for New User Signups.")


================================================================================

File: ./metrics/weekly_intervals.py
Lines of code: 209
--------------------------------------------------------------------------------

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go  # Add this import
from datetime import datetime, timezone
import numpy as np


def get_extrapolated_weekly_data(df: pd.DataFrame, date_column: str, count_column: str = None, 
                                agg_function: str = 'count') -> pd.DataFrame:
    if df.empty:
        return pd.DataFrame()
    
    # Ensure datetime is UTC
    df = df.copy()
    df[date_column] = pd.to_datetime(df[date_column], utc=True)
    
    # Define start date and calculate weeks
    start_date = pd.Timestamp('2024-09-29', tz='UTC')
    df['week_number'] = ((df[date_column] - start_date) // pd.Timedelta(weeks=1)) + 1
    df['week_start'] = start_date + (df['week_number'] - 1) * pd.Timedelta(weeks=1)
    
    # Get current week information
    today = pd.Timestamp.now(tz='UTC')
    current_week_start = today - pd.Timedelta(days=today.weekday() + 1 if today.weekday() != 6 else 0)
    days_elapsed = (today - current_week_start).days + 1
    
    # Separate current week and historical data
    current_week = df[df['week_start'] == current_week_start]
    historical_data = df[df['week_start'] < current_week_start]
    
    # Aggregate historical data based on function type
    if agg_function == 'unique_count':
        weekly_data = historical_data.groupby('week_start')[count_column].nunique()
    elif agg_function == 'mean':
        weekly_data = historical_data.groupby(['week_start', count_column]).size().reset_index(name='count')
        weekly_data = weekly_data.groupby('week_start')['count'].mean()
    else:  # count
        weekly_data = historical_data.groupby('week_start').size()
    
    weekly_data = weekly_data.reset_index()
    weekly_data.columns = ['week_start', 'value']
    weekly_data['is_extrapolated'] = False
    
    # Calculate and append extrapolated data if we have current week data
    if not current_week.empty:
        if agg_function == 'unique_count':
            current_value = current_week[count_column].nunique()
        elif agg_function == 'mean':
            current_value = current_week.groupby(count_column).size().mean()
        else:
            current_value = len(current_week)
        
        # Extrapolate to full week
        extrapolated_value = np.ceil((current_value / days_elapsed) * 7)
        
        extrapolated_row = pd.DataFrame({
            'week_start': [current_week_start],
            'value': [extrapolated_value],
            'is_extrapolated': [True]
        })
        
        weekly_data = pd.concat([weekly_data, extrapolated_row], ignore_index=True)
    
    return weekly_data.sort_values('week_start', ascending=True)


def create_time_series_plot(data: pd.DataFrame, 
                            title: str,
                            y_axis_title: str,
                            color: str = '#1f77b4',
                            show_growth: bool = True) -> go.Figure:
    """
    Create a consistent time series plot with improved styling
    """
    # Calculate period-over-period growth
    if show_growth and len(data) > 1:
        data = data.copy()
        data['growth'] = data['value'].pct_change() * 100
    
    fig = px.line(
        data,
        x='week_start',
        y='value',
        title=title,
        markers=True,
        color_discrete_sequence=[color]
    )
    
    # Update layout
    fig.update_layout(
        hovermode='x unified',
        hoverlabel=dict(
            bgcolor="white",
            font_size=14,
            font_color="black",
            bordercolor="black"
        ),
        title=dict(
            text=title,
            x=0.5,
            y=0.95,
            xanchor='center',
            yanchor='top',
            font_size=24
        ),
        xaxis_title="Week Starting",
        yaxis_title=y_axis_title,
        height=600,
        xaxis=dict(tickangle=-45)
    )
    
    # Style the lines differently for actual vs extrapolated data
    for i, row in data.iterrows():
        if row['is_extrapolated']:
            fig.add_scatter(
                x=[row['week_start']],
                y=[row['value']],
                mode='markers+lines',
                line=dict(dash='dot', color=color),
                marker=dict(size=10, color=color, symbol='star'),
                name='Projected',
                showlegend=i == len(data) - 1,
                hovertemplate="<br>".join([
                    "<b>Week Starting:</b> %{x|%Y-%m-%d}",
                    f"<b>{y_axis_title}:</b> %{{y:.1f}} (Projected)",
                    "<extra></extra>"
                ])
            )
    
    # Update main trace
    fig.update_traces(
        line=dict(width=2),
        marker=dict(size=8),
        hovertemplate="<br>".join([
            "<b>Week Starting:</b> %{x|%Y-%m-%d}",
            f"<b>{y_axis_title}:</b> %{{y:.1f}}",
            f"<b>Growth:</b> {'+' if show_growth else ''}" + "%{customdata[0]:.1f}%" if show_growth else "",
            "<extra></extra>"
        ]),
        customdata=data[['growth']] if show_growth else None,
        selector=dict(mode='lines+markers')
    )
    
    return fig

def display_weekly_metrics(data_df: pd.DataFrame, 
                         metric_name: str,
                         date_column: str = 'created_at',
                         count_column: str = None,
                         agg_function: str = 'count',
                         color: str = '#1f77b4') -> None:
    """
    Display weekly metrics with improved visualization
    """
    st.header(f'{metric_name} (Weekly)')
    
    if data_df.empty:
        st.write(f"No data available for {metric_name}")
        return
    
    # Get weekly data with extrapolation
    weekly_data = get_extrapolated_weekly_data(
        data_df, 
        date_column, 
        count_column, 
        agg_function
    )
    
    # Create and display plot
    fig = create_time_series_plot(
        weekly_data,
        title=f'{metric_name} (Weekly)',
        y_axis_title=metric_name,
        color=color
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Display data table with clear extrapolation marking
    display_df = weekly_data.copy()
    display_df['Status'] = display_df['is_extrapolated'].map({True: '📊 Projected', False: '✓ Actual'})
    display_df = display_df.drop('is_extrapolated', axis=1)
    display_df.columns = ['Week Starting', 'Value', 'Status']
    
    st.subheader(f"Weekly {metric_name} Data")
    st.dataframe(
        display_df.sort_values('Week Starting', ascending=False),
        hide_index=True
    )

def display_weekly_streams(streams_df):
    display_weekly_metrics(
        streams_df,
        "Stream Count",
        'created_at',
        color='#1f77b4'
    )

def display_weekly_active_users(streams_df):
    display_weekly_metrics(
        streams_df,
        "Active Users",
        'created_at',
        'user_id',
        'unique_count',
        color='#ff7f0e'
    )


================================================================================

File: ./retool.py
Lines of code: 198
--------------------------------------------------------------------------------

import streamlit as st
from supabase import create_client
import pandas as pd
import numpy as np
from dotenv import load_dotenv
from datetime import datetime, timezone

# Import metric components
from metrics.avg_streams_per_user import display_avg_streams_per_user
from metrics.monthly_total_streams import display_monthly_total_streams
from metrics.monthly_active_users import display_monthly_active_users
from metrics.monthly_retention import display_monthly_retention
from metrics.new_user_signups import display_new_user_signups
from metrics.weekly_intervals import display_weekly_streams, display_weekly_active_users

# Load environment variables
load_dotenv()


def display_summary_metrics(streams: pd.DataFrame, users: pd.DataFrame) -> None:
    """
    Display the summary metrics section with improved layout and calculations
    """
    st.header('Summary Metrics', divider='blue')
    
    # Create two rows of metrics for better spacing
    row1_cols = st.columns([1, 1])
    row2_cols = st.columns([1, 1])
    
    # 1. Average Streams per Week per User
    with row1_cols[0]:
        if not streams.empty:
            # Calculate using complete weeks only
            start_date = pd.Timestamp('2024-09-29', tz='UTC')
            df = streams.copy()
            df['week_number'] = ((df['created_at'] - start_date) // pd.Timedelta(weeks=1)) + 1
            df['week_start'] = start_date + (df['week_number'] - 1) * pd.Timedelta(weeks=1)
            
            # Get complete weeks only (exclude current week)
            today = pd.Timestamp.now(tz='UTC')
            complete_weeks_data = df[df['week_start'] < today - pd.Timedelta(days=today.weekday())]
            
            if not complete_weeks_data.empty:
                weekly_streams = complete_weeks_data.groupby(['week_start', 'user_id']).size().reset_index(name='streams')
                avg_streams = weekly_streams.groupby('week_start')['streams'].mean().mean()
                
                st.metric(
                    "Average Weekly Streams/User",
                    f"{avg_streams:.1f}",
                    help="Average number of streams per user per week (excluding current week)"
                )
            else:
                st.metric("Average Weekly Streams/User", "0.0")
        else:
            st.metric("Average Weekly Streams/User", "No data")

    # 2. Monthly Active Users (MAU)
    with row1_cols[1]:
        if not streams.empty:
            current_date = pd.Timestamp.now(tz='UTC')
            thirty_days_ago = current_date - pd.Timedelta(days=30)
            active_users = len(streams[streams['created_at'] >= thirty_days_ago]['user_id'].unique())
            
            st.metric(
                "Monthly Active Users",
                f"{active_users:,}",
                help="Unique users who streamed in the last 30 days"
            )
        else:
            st.metric("Monthly Active Users", "No data")

    # 3. Total Users
    with row2_cols[0]:
        if not users.empty:
            total_users = len(users)
            # Calculate user growth
            last_month = pd.Timestamp.now(tz='UTC') - pd.Timedelta(days=30)
            prev_total = len(users[users['created_at'] < last_month])
            growth = ((total_users - prev_total) / prev_total * 100) if prev_total > 0 else 0
            
            st.metric(
                "Total Users",
                f"{total_users:,}",
                f"{growth:+.1f}% in 30 days",
                help="Total number of registered users"
            )
        else:
            st.metric("Total Users", "No data")

    # 4. Premium Users
    with row2_cols[1]:
        if not users.empty:
            premium_users = users[users['is_paying'] == True].shape[0]
            total_users = len(users)
            premium_percentage = (premium_users / total_users * 100) if total_users > 0 else 0
            
            st.metric(
                "Premium Users",
                f"{premium_users:,}",
                f"{premium_percentage:.1f}% of total",
                help="Number of users with premium subscriptions"
            )
        else:
            st.metric("Premium Users", "No data")

def create_analytics_dashboard():
    """
    Create and display the main analytics dashboard with all metrics and visualizations
    """
    try:
        # Initialize Supabase client
        supabase_url = st.secrets["env"]["SUPABASE_URL"]
        supabase_key = st.secrets["env"]["SUPABASE_KEY"]
        supabase = create_client(supabase_url, supabase_key)

        # List of developer user IDs to exclude
        developer_ids = st.secrets["env"]["DEVELOPER_IDS"].split(',')

        # Set page config
        st.set_page_config(
            page_title="Platform Analytics",
            page_icon="📊",
            layout="wide",
            initial_sidebar_state="expanded"
        )

        # Fetch data from all tables
        with st.spinner('Fetching data...'):
            streams = pd.DataFrame(supabase.from_('Streams').select('*').execute().data)
            highlights = pd.DataFrame(supabase.from_('Highlights').select('*').execute().data)
            users = pd.DataFrame(supabase.from_('Users').select('*').execute().data)

            # Filter out developer data
            streams = streams[~streams['user_id'].isin(developer_ids)]
            highlights = highlights[~highlights['user_id'].isin(developer_ids)]
            users = users[~users['user_id'].isin(developer_ids)]

        # Convert timestamps to datetime with UTC
        if not streams.empty:
            streams['created_at'] = pd.to_datetime(streams['created_at'], utc=True)
        if not users.empty:
            users['created_at'] = pd.to_datetime(users['created_at'], utc=True)

        # Main dashboard title with styling
        st.title('📊 Platform Analytics Dashboard')
        st.caption('Data excludes developer activity')

        # Add data freshness indicator
        last_update = pd.Timestamp.now(tz='UTC')
        st.sidebar.info(f"Data last updated: {last_update.strftime('%Y-%m-%d %H:%M:%S')} UTC")

        # Display summary metrics
        display_summary_metrics(streams, users)

        st.caption("📊 Dotted lines and star markers (⭐) indicate projected data for the current period")


        # Create tabs for different metric categories
        tabs = st.tabs(["User Activity", "Retention", "Growth"])

        with tabs[0]:
            st.header("User Activity Metrics")
            
            st.subheader("Monthly Metrics")
            display_monthly_total_streams(streams)
            
            st.subheader("Weekly Metrics")
            display_avg_streams_per_user(streams)
            display_weekly_streams(streams)
            display_weekly_active_users(streams)

        with tabs[1]:
            st.header("Retention Metrics")
            # Display retention metrics
            display_monthly_retention(streams)

        with tabs[2]:
            st.header("Growth Metrics")
            # Display growth metrics
            display_new_user_signups(users)
            
            # Display highlights metrics if available
            if not highlights.empty:
                st.subheader("Highlights Activity")
                # Add your highlights metrics here

        # Add footer with data disclaimer
        st.markdown("---")
        st.caption("Note: All metrics are calculated based on UTC timezone")

    except Exception as e:
        st.error(f"An error occurred: {str(e)}")
        st.error("Please check your database connection and try again.")
        # Log the full error for debugging
        st.exception(e)

if __name__ == "__main__":
    create_analytics_dashboard()

================================================================================


Summary:
Total Python files processed: 9
Total lines of Python code: 905
